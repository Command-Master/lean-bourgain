import Pseudorandom.Extractor
import Pseudorandom.LpLemmas
import Mathlib.LinearAlgebra.BilinearForm.Basic

open BigOps ComplexConjugate Finset

theorem AddChar.eq_iff [AddGroup Œ±] [GroupWithZero R] (œá : AddChar Œ± R) : œá a = œá b ‚Üî œá (a - b) = 1 := by
  simp [sub_eq_add_neg, AddChar.map_add_mul, AddChar.map_neg_inv]
  apply Iff.symm
  apply mul_inv_eq_one‚ÇÄ
  apply_fun (¬∑ * œá (-b))
  simp only [zero_mul, ne_eq, ‚Üê AddChar.map_add_mul, add_right_neg, map_zero_one, one_ne_zero, not_false_eq_true]

def IP [CommSemiring Œ±] : BilinForm Œ± (Œ± √ó Œ±) := {
  bilin := fun x y => (x.1*y.1 + x.2*y.2)
  bilin_add_left := by intros; simp; ring_nf
  bilin_add_right := by intros; simp; ring_nf
  bilin_smul_left := by intros; simp; ring_nf
  bilin_smul_right := by intros; simp; ring_nf
}

lemma IP_comm [CommSemiring Œ±] (a b : Œ± √ó Œ±) : IP a b = IP b a := by
  unfold IP
  simp [mul_comm]

theorem apply_inner_product_injective [Field Œ±] (œá : AddChar Œ± ‚ÑÇ) (h : œá.IsNontrivial) :
    Function.Injective (fun x : Œ± √ó Œ± => {
      toFun := fun y : Œ± √ó Œ± => œá (IP x y)
      map_zero_one' := by simp
      map_add_mul' := by
        intro a b
        simp [‚Üê AddChar.map_add_mul]
      : AddChar (Œ± √ó Œ±) ‚ÑÇ
    }) := by
  obtain ‚ü®x, hx‚ü© := h
  rintro ‚ü®a1, a2‚ü© ‚ü®b1, b2‚ü© v
  simp only [AddChar.mk.injEq] at v
  simp only [Prod.mk.injEq]
  constructor
  ¬∑ by_contra! nh
    apply sub_ne_zero_of_ne at nh
    have := congr($v (x / (a1 - b1), 0))
    simp only [mul_zero, add_zero] at this
    rw [AddChar.eq_iff] at this
    replace this : œá x = 1 := by
      convert this
      unfold IP
      field_simp
      ring_nf
    simp [this] at hx
  ¬∑ by_contra! nh
    apply sub_ne_zero_of_ne at nh
    have := congr($v (0, x / (a2 - b2)))
    simp only [mul_zero, add_zero] at this
    rw [AddChar.eq_iff] at this
    replace this : œá x = 1 := by
      convert this
      unfold IP
      field_simp
      ring_nf
    simp [this] at hx

theorem apply_inner_product_bijective [Fintype Œ±] [Field Œ±] (œá : AddChar Œ± ‚ÑÇ) (h : œá.IsNontrivial) :
    Function.Bijective (fun x : Œ± √ó Œ± => {
      toFun := fun y : Œ± √ó Œ± => œá (IP x y)
      map_zero_one' := by simp
      map_add_mul' := by
        intro a b
        simp [‚Üê AddChar.map_add_mul]
      : AddChar (Œ± √ó Œ±) ‚ÑÇ
    }) := (Fintype.bijective_iff_injective_and_card _).mpr ‚ü®apply_inner_product_injective œá h, by simp‚ü©

noncomputable def AddChar.inner_product_equiv [Fintype Œ±] [Field Œ±] (œá : AddChar Œ± ‚ÑÇ) (h : œá.IsNontrivial) :
  (Œ± √ó Œ±) ‚âÉ AddChar (Œ± √ó Œ±) ‚ÑÇ := Equiv.ofBijective _ (apply_inner_product_bijective œá h)

theorem bourgain_extractor_aux_inner [Fintype Œ±] [Field Œ±] (a b : (Œ± √ó Œ±) ‚Üí ‚Ñù) (œá : AddChar Œ± ‚ÑÇ) (h : œá.IsNontrivial) :
    ‚Äñ ‚àë x, a x * ‚àë y, b y * œá (IP x y)‚Äñ = ‚Äñ l2Inner (Complex.ofReal ‚àò a) (fun x => dft (b ¬∑) (œá.inner_product_equiv h x)‚Åª¬π)‚Äñ
        := calc ‚Äñ ‚àë x, a x * ‚àë y, b y * œá (IP x y)‚Äñ
  _ = ‚Äñ ‚àë x, a x * ‚àë y, b y * (œá.inner_product_equiv h x) y‚Äñ := rfl
  _ = ‚Äñ ‚àë x, a x * ‚àë y, (œá.inner_product_equiv h x) y * b y‚Äñ := by congr; ext; congr; ext; rw [mul_comm]
  _ = ‚Äñ ‚àë x, a x * ‚àë y, conj ((œá.inner_product_equiv h x)‚Åª¬π y) * b y‚Äñ := by
    congr; ext; congr; ext
    rw [AddChar.inv_apply, AddChar.map_neg_eq_conj, RingHomCompTriple.comp_apply, RingHom.id_apply]
  _ = ‚Äñ ‚àë x, a x * (dft (b ¬∑) (œá.inner_product_equiv h x)‚Åª¬π)‚Äñ := rfl
  _ = ‚Äñ l2Inner (Complex.ofReal ‚àò a) (fun x => dft (b ¬∑) (œá.inner_product_equiv h x)‚Åª¬π)‚Äñ := by
    unfold l2Inner
    rcongr
    simp only [Function.comp_apply, Complex.ofReal_eq_coe, Complex.conj_ofReal]

theorem bourgain_extractor_aux‚ÇÄ [Fintype Œ±] [Field Œ±] (a b : (Œ± √ó Œ±) ‚Üí ‚Ñù) (œá : AddChar Œ± ‚ÑÇ) (h : œá.IsNontrivial) :
    ‚Äñ ‚àë x, a x * ‚àë y, b y * œá (IP x y)‚Äñ^2 ‚â§ (Fintype.card Œ±)^2 * ‚Äña‚Äñ_[2]^2 * ‚Äñb‚Äñ_[2]^2 :=
      calc ‚Äñ ‚àë x, a x * ‚àë y, b y * œá (IP x y)‚Äñ^2
  _ = ‚Äñ ‚àë x, a x * ‚àë y, b y * (œá.inner_product_equiv h x) y‚Äñ^2 := rfl
  _ = ‚Äñ ‚àë x, a x * ‚àë y, (œá.inner_product_equiv h x) y * b y‚Äñ^2 := by congr; ext; congr; ext; rw [mul_comm]
  _ = ‚Äñ ‚àë x, a x * ‚àë y, conj ((œá.inner_product_equiv h x)‚Åª¬π y) * b y‚Äñ^2 := by
    congr; ext; congr; ext
    rw [AddChar.inv_apply, AddChar.map_neg_eq_conj, RingHomCompTriple.comp_apply, RingHom.id_apply]
  _ = ‚Äñ ‚àë x, a x * (dft (b ¬∑) (œá.inner_product_equiv h x)‚Åª¬π)‚Äñ^2 := rfl
  _ = ‚Äñ l2Inner (Complex.ofReal ‚àò a) (fun x => dft (b ¬∑) (œá.inner_product_equiv h x)‚Åª¬π)‚Äñ^2 := by
    unfold l2Inner
    rcongr
    simp only [Function.comp_apply, Complex.ofReal_eq_coe, Complex.conj_ofReal]
  _ ‚â§ (‚Äñ(Complex.ofReal ‚àò a)‚Äñ_[2] * ‚Äñ(fun x => dft (b ¬∑) (œá.inner_product_equiv h x)‚Åª¬π) ‚Äñ_[2])^2 := by
    gcongr
    apply norm_l2Inner_le_lpNorm_mul_lpNorm
    rw [NNReal.isConjExponent_iff_eq_conjExponent]
    rw [NNReal.sub_def]
    norm_num
    norm_num
  _ = ‚Äñ(Complex.ofReal ‚àò a)‚Äñ_[2]^2 * ‚Äñ(fun x => dft (b ¬∑) (œá.inner_product_equiv h x)‚Åª¬π) ‚Äñ_[2]^2 := by
    ring_nf
  _ = ‚Äñ(Complex.ofReal ‚àò a)‚Äñ_[2]^2 * ‚àë x, ‚Äñdft (b ¬∑) (œá.inner_product_equiv h x)‚Åª¬π‚Äñ^2 := by
    conv =>
      lhs
      rhs
      rw [l2Norm_sq_eq_sum]
  _ = ‚Äñ(Complex.ofReal ‚àò a)‚Äñ_[2]^2 * ‚àë x, ‚Äñdft (b ¬∑) ((AddChar.inner_product_equiv œá h).trans (Equiv.inv _) x)‚Äñ^2 := rfl
  _ = ‚Äñ(Complex.ofReal ‚àò a)‚Äñ_[2]^2 * ‚àë x, ‚Äñdft (b ¬∑) x‚Äñ^2 := by
    congr 1
    apply Fintype.sum_equiv ((AddChar.inner_product_equiv œá h).trans (Equiv.inv _))
    intros
    rfl
  _ = ‚Äñ(Complex.ofReal ‚àò a)‚Äñ_[2]^2 * (Fintype.card (Œ± √ó Œ±) * ùîº x, ‚Äñdft (b ¬∑) x‚Äñ^2) := by
    congr 2
    rw [Finset.expect_univ, ‚Üê nnratCast_smul_eq_nnqsmul ‚Ñù]
    field_simp
    ring_nf
  _ = ‚Äñ(Complex.ofReal ‚àò a)‚Äñ_[2]^2 * (Fintype.card (Œ± √ó Œ±) * ‚Äñdft (b ¬∑)‚Äñ‚Çô_[2]^2) := by
    rw [nl2Norm_sq_eq_expect]
  _ = ‚Äñ(Complex.ofReal ‚àò a)‚Äñ_[2]^2 * (Fintype.card (Œ± √ó Œ±) * ‚Äñ(Complex.ofReal ‚àò b)‚Äñ_[2]^2) := by
    rw [nl2Norm_dft]
    rfl
  _ = ‚Äñ(Complex.ofReal ‚àò a)‚Äñ_[2]^2 * ((Fintype.card Œ±)^2 * ‚Äñ(Complex.ofReal ‚àò b)‚Äñ_[2]^2) := by
    congr
    simp only [Fintype.card_prod, Nat.cast_mul, sq]
  _ = (Fintype.card Œ±)^2 * ‚Äñ(Complex.ofReal ‚àò a)‚Äñ_[2]^2 * ‚Äñ(Complex.ofReal ‚àò b)‚Äñ_[2]^2 := by ring
  _ = (Fintype.card Œ±)^2 * ‚Äñ(Complex.ofReal' ‚àò a)‚Äñ_[2]^2 * ‚Äñ(Complex.ofReal' ‚àò b)‚Äñ_[2]^2 := rfl
  _ = (Fintype.card Œ±)^2 * ‚Äña‚Äñ_[2]^2 * ‚Äñb‚Äñ_[2]^2 := by
    rw [Complex.lpNorm_coe_comp, Complex.lpNorm_coe_comp]

theorem bourgain_extractor_aux‚ÇÄ' [Fintype Œ±] [Field Œ±] (a b : (Œ± √ó Œ±) ‚Üí ‚Ñù) (œá : AddChar Œ± ‚ÑÇ) (h : œá.IsNontrivial) :
    ‚Äñ ‚àë x, a x * ‚àë y, b y * œá (IP x y)‚Äñ ‚â§ (Fintype.card Œ±) * ‚Äña‚Äñ_[2] * ‚Äñb‚Äñ_[2] := by
  have := bourgain_extractor_aux‚ÇÄ a b œá h
  rw [‚Üê mul_pow, ‚Üê mul_pow, sq_le_sq, abs_of_nonneg, abs_of_nonneg] at this
  exact this
  positivity
  positivity

theorem bourgain_extractor_aux‚ÇÅ [Fintype Œ±] [Field Œ±] [Fintype Œ≤] [AddCommGroup Œ≤] [Module Œ± Œ≤]
    (a b : FinPMF Œ≤) (œá : AddChar Œ± ‚ÑÇ) (F : BilinForm Œ± Œ≤) :
    ‚Äñ ‚àë x, a x * ‚àë y, b y * œá (F x y)‚Äñ^2 ‚â§ ‚Äñ ‚àë x, a x * ‚àë y, (b - b) y * œá (F x y)‚Äñ := by
  calc ‚Äñ ‚àë x, a x * ‚àë y, b y * œá (F x y)‚Äñ^2
    _ ‚â§ (‚àë x, ‚Äña x * ‚àë y, b y * œá (F x y)‚Äñ)^2 := by
      gcongr
      apply norm_sum_le
    _ = (‚àë x, a x * ‚Äñ‚àë y, b y * œá (F x y)‚Äñ)^2 := by
      rcongr
      simp
    _ = (‚àë x, Real.sqrt (a x) * (Real.sqrt (a x) * ‚Äñ‚àë y, b y * œá (F x y)‚Äñ))^2 := by
      simp_rw [‚Üê mul_assoc]
      rcongr
      simp
    _ ‚â§ (‚àë x, Real.sqrt (a x)^2) * (‚àë x, (Real.sqrt (a x) * ‚Äñ‚àë y, b y * œá (F x y)‚Äñ)^2) := by
      apply sum_mul_sq_le_sq_mul_sq
    _ = (‚àë x, a x) * (‚àë x, a x * ‚Äñ‚àë y, b y * œá (F x y)‚Äñ^2) := by
      rcongr
      simp
      ring_nf
      simp only [FinPMF.nonneg, Real.sq_sqrt]
      ring
    _ = ‚àë x, a x * ‚Äñ‚àë y, b y * œá (F x y)‚Äñ^2 := by simp
    _ = ‚Äñ(‚àë x, a x * ‚Äñ‚àë y, b y * œá (F x y)‚Äñ^2 : ‚ÑÇ)‚Äñ := by
      apply_fun Complex.ofReal'
      push_cast
      apply Complex.eq_coe_norm_of_nonneg
      rw [Complex.nonneg_iff]
      constructor
      simp only [Complex.norm_eq_abs, Complex.re_sum, Complex.mul_re, Complex.ofReal_re,
        Complex.ofReal_im, zero_mul, sub_zero]
      apply sum_nonneg
      intros
      norm_cast
      apply mul_nonneg
      simp
      simp
      simp only [Complex.norm_eq_abs, Complex.im_sum, Complex.mul_im, Complex.ofReal_re,
        Complex.ofReal_im, zero_mul, add_zero]
      apply Eq.symm
      apply sum_eq_zero
      intros
      norm_cast
      simp
      exact Complex.ofReal_injective
    _ = ‚Äñ(‚àë x, a x * Complex.normSq (‚àë y, b y * œá (F x y)) : ‚ÑÇ)‚Äñ := by simp_rw [Complex.normSq_eq_norm_sq]; norm_cast
    _ = ‚Äñ(‚àë x, a x * (conj (‚àë y, b y * œá (F x y)) * ‚àë y, b y * œá (F x y)) : ‚ÑÇ)‚Äñ := by simp_rw [Complex.normSq_eq_conj_mul_self]
    _ = ‚Äñ(‚àë x, a x * ((‚àë y, b y * œá (- F x y)) * ‚àë y, b y * œá (F x y)) : ‚ÑÇ)‚Äñ := by
      rcongr
      simp
      rcongr
      apply Complex.conj_ofReal
      rw [AddChar.map_neg_eq_conj]
    _ = ‚Äñ(‚àë x, a x * (‚àë y‚ÇÅ, ‚àë y‚ÇÇ, b y‚ÇÅ * b y‚ÇÇ * œá (F x (y‚ÇÅ - y‚ÇÇ))) : ‚ÑÇ)‚Äñ := by
      rcongr x
      rw [mul_comm, sum_mul_sum]
      congr with y‚ÇÅ
      congr with y‚ÇÇ
      convert_to ((b y‚ÇÅ) * (b y‚ÇÇ)) * (œá (F x y‚ÇÅ) * œá (- F x y‚ÇÇ)) = ((b y‚ÇÅ) * (b y‚ÇÇ)) * œá (F x (y‚ÇÅ - y‚ÇÇ))
      ring_nf
      rw [‚Üê AddChar.map_add_mul]
      congr
      simp_rw [BilinForm.sub_right (B‚ÇÅ := F) x y‚ÇÅ y‚ÇÇ]
      ring_nf
    _ = ‚Äñ(‚àë x, a x * (‚àë y in univ √óÀ¢ univ, b y.1 * b y.2 * œá (F x (y.1 - y.2))) : ‚ÑÇ)‚Äñ := by
      congr with x
      congr 1
      rw [Finset.sum_product' (f := fun y‚ÇÅ y‚ÇÇ => b y‚ÇÅ * b y‚ÇÇ * œá (F x (y‚ÇÅ - y‚ÇÇ)))]
    _ = ‚Äñ(‚àë x, a x * (‚àë y : Œ≤ √ó Œ≤, b y.1 * b y.2 * œá (F x (y.1 - y.2))) : ‚ÑÇ)‚Äñ := rfl
    _ = ‚Äñ ‚àë x, a x * ‚àë y, (b - b) y * œá (F x y)‚Äñ := by
      congr with x
      congr 1
      simp_rw [instSubFinPMF]
      conv =>
        rhs
        exact apply_weighted_sum ..
      rcongr ‚ü®x1, x2‚ü©
      simp
      rfl

theorem bourgain_extractor_aux‚ÇÅ' [Fintype Œ±] [Field Œ±] [Fintype Œ≤] [AddCommGroup Œ≤] [Module Œ± Œ≤]
    (a b : FinPMF Œ≤) (œá : AddChar Œ± ‚ÑÇ) (F : BilinForm Œ± Œ≤) :
    ‚Äñ ‚àë x, a x * ‚àë y, b y * œá (F x y)‚Äñ ‚â§ ‚Äñ ‚àë x, a x * ‚àë y, (b - b) y * œá (F x y)‚Äñ^(2‚Åª¬π : ‚Ñù) := by
  rw [Real.le_rpow_inv_iff_of_pos, Real.rpow_two]
  apply bourgain_extractor_aux‚ÇÅ a b œá F
  simp only [Complex.norm_eq_abs, apply_nonneg]
  simp only [Complex.norm_eq_abs, apply_nonneg]
  norm_num

theorem bourgain_extractor_aux‚ÇÇ (Œµ : ‚Ñù) (hŒµ : 0 < Œµ) (n : ‚Ñù) (hn : 0 < n) [Fintype Œ±] [Field Œ±] [DecidableEq (Œ± √ó Œ±)] (a b : FinPMF (Œ± √ó Œ±)) (œá : AddChar Œ± ‚ÑÇ)
    (h : œá.IsNontrivial) (hA : close_high_entropy n Œµ a) (hB : close_high_entropy n Œµ b):
    ‚Äñ ‚àë x, a x * ‚àë y, b y * œá (IP x y)‚Äñ ‚â§ Fintype.card Œ± / n + 2 * Œµ := calc ‚Äñ ‚àë x, a x * ‚àë y, b y * œá (IP x y)‚Äñ
  _ = ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y, b y * œá (IP x y) +
      ‚àë x ‚àà univ.filter (fun x => ¬¨a x ‚â§ 1/n), a x * ‚àë y, b y * œá (IP x y)‚Äñ := by rw [sum_filter_add_sum_filter_not]
  _ ‚â§ ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y, b y * œá (IP x y)‚Äñ +
      ‚Äñ‚àë x ‚àà univ.filter (fun x => ¬¨a x ‚â§ 1/n), a x * ‚àë y, b y * œá (IP x y)‚Äñ := norm_add_le ..
  _ ‚â§ ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y, b y * œá (IP x y)‚Äñ +
      ‚àë x ‚àà univ.filter (fun x => ¬¨a x ‚â§ 1/n), ‚Äña x * ‚àë y, b y * œá (IP x y)‚Äñ := by
    gcongr
    apply norm_sum_le
  _ = ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y, b y * œá (IP x y)‚Äñ +
      ‚àë x ‚àà univ.filter (fun x => ¬¨a x ‚â§ 1/n), ‚Äña x‚Äñ * ‚Äñ‚àë y, b y * œá (IP x y)‚Äñ := by
    simp only [one_div, Fintype.sum_prod_type, Complex.norm_eq_abs, not_le, norm_mul,
      Complex.abs_ofReal, Real.norm_eq_abs]
  _ ‚â§ ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y, b y * œá (IP x y)‚Äñ +
      ‚àë x ‚àà univ.filter (fun x => ¬¨a x ‚â§ 1/n), ‚Äña x‚Äñ * ‚àë y, ‚Äñb y * œá (IP x y)‚Äñ := by
    gcongr
    apply norm_sum_le
  _ = ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y, b y * œá (IP x y)‚Äñ +
      ‚àë x ‚àà univ.filter (fun x => ¬¨a x ‚â§ 1/n), ‚Äña x‚Äñ * ‚àë y, ‚Äñb y‚Äñ := by simp only [one_div,
        Fintype.sum_prod_type, Complex.norm_eq_abs, not_le, Real.norm_eq_abs, norm_mul,
        Complex.abs_ofReal, AddChar.norm_apply, mul_one]
  _ = ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y, b y * œá (IP x y)‚Äñ +
      ‚àë x ‚àà univ.filter (fun x => ¬¨a x ‚â§ 1/n), a x := by simp only [one_div,
        Fintype.sum_prod_type, Complex.norm_eq_abs, not_le, Real.norm_eq_abs, ge_iff_le,
        FinPMF.nonneg, abs_of_nonneg, FinPMF.sum_coe, mul_one]
  _ ‚â§ ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y, b y * œá (IP x y)‚Äñ + Œµ := by
    gcongr
    apply hA
    apply filter_neg_le_inv_card_le
    assumption
  _ = ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x *
      (‚àë y ‚àà univ.filter (fun y => b y ‚â§ 1/n), b y * œá (IP x y) + ‚àë y ‚àà univ.filter (fun y => ¬¨b y ‚â§ 1/n), b y * œá (IP x y))‚Äñ + Œµ := by
    simp_rw [sum_filter_add_sum_filter_not]
  _ = ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => b y ‚â§ 1/n), b y * œá (IP x y) +
      ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => ¬¨b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ + Œµ := by
    simp_rw [mul_add, sum_add_distrib]
  _ ‚â§ ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ +
      ‚Äñ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => ¬¨b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ + Œµ := by
    gcongr
    apply norm_add_le
  _ ‚â§ ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ +
      ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), ‚Äña x * ‚àë y ‚àà univ.filter (fun y => ¬¨b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ + Œµ := by
    gcongr
    apply norm_sum_le
  _ = ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ +
      ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), ‚Äña x‚Äñ * ‚Äñ‚àë y ‚àà univ.filter (fun y => ¬¨b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ + Œµ := by
    simp only [one_div, Complex.norm_eq_abs, not_le, norm_mul, Complex.abs_ofReal, Real.norm_eq_abs]
  _ ‚â§ ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ +
      ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), ‚Äña x‚Äñ * ‚àë y ‚àà univ.filter (fun y => ¬¨b y ‚â§ 1/n), ‚Äñb y * œá (IP x y)‚Äñ + Œµ := by
    gcongr
    apply norm_sum_le
  _ = ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ +
      ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => ¬¨b y ‚â§ 1/n), b y + Œµ := by
    simp only [one_div, Complex.norm_eq_abs, Real.norm_eq_abs, ge_iff_le, FinPMF.nonneg,
      abs_of_nonneg, not_le, norm_mul, Complex.abs_ofReal, AddChar.norm_apply, mul_one]
  _ ‚â§ ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ +
      ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * Œµ + Œµ := by
    gcongr
    simp
    apply hB
    apply filter_neg_le_inv_card_le
    assumption
  _ ‚â§ ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ +
      ‚àë x ‚àà univ, a x * Œµ + Œµ := by
    gcongr
    apply sum_le_sum_of_subset_of_nonneg
    simp
    intros
    apply mul_nonneg
    simp
    exact le_of_lt hŒµ
  _ = ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ +
      Œµ + Œµ := by rw [‚Üê sum_mul]; simp
  _ = ‚Äñ ‚àë x ‚àà univ.filter (fun x => a x ‚â§ 1/n), a x * ‚àë y ‚àà univ.filter (fun y => b y ‚â§ 1/n), b y * œá (IP x y)‚Äñ +
      2 * Œµ := by ring
  _ = ‚Äñ ‚àë x, (if a x ‚â§ 1/n then a x else 0) *
        ‚àë y, (if b y ‚â§ 1/n then b y else 0) * œá (IP x y)‚Äñ +
      2 * Œµ := by
    congr 2
    apply Finset.sum_subset_zero_on_sdiff
    ¬∑ simp
    ¬∑ intros
      simp_all
    ¬∑ intros
      simp_all only [one_div, mem_filter, mem_univ, true_and, ite_true,
        mul_eq_mul_left_iff, Complex.ofReal_eq_zero]
      left
      apply Finset.sum_subset_zero_on_sdiff
      ¬∑ simp
      ¬∑ intros
        simp_all
      ¬∑ intros
        simp_all
  _ ‚â§ (Fintype.card Œ±) * ‚Äñfun x => (if a x ‚â§ 1/n then a x else 0)‚Äñ_[2] * ‚Äñfun y => (if b y ‚â§ 1/n then b y else 0)‚Äñ_[2] + 2*Œµ := by
    gcongr
    apply bourgain_extractor_aux‚ÇÄ'
    exact h
  _ ‚â§ (Fintype.card Œ±) * Real.sqrt (‚Äñfun x => (if a x ‚â§ 1/n then a x else 0)‚Äñ_[1] * ‚Äñfun x => (if a x ‚â§ 1/n then a x else 0)‚Äñ_[‚ä§])
      * Real.sqrt (‚Äñfun y => (if b y ‚â§ 1/n then b y else 0)‚Äñ_[1] * ‚Äñfun y => (if b y ‚â§ 1/n then b y else 0)‚Äñ_[‚ä§]) + 2*Œµ := by
    gcongr <;> apply l2Norm_le_sqrt_l1Norm_mul_linftyNorm
  _ = (Fintype.card Œ±) * Real.sqrt ((‚àë x, ‚Äñif a x ‚â§ 1/n then a x else 0‚Äñ) * ‚Äñfun x => (if a x ‚â§ 1/n then a x else 0)‚Äñ_[‚ä§])
      * Real.sqrt ((‚àë y, ‚Äñif b y ‚â§ 1/n then b y else 0‚Äñ) * ‚Äñfun y => (if b y ‚â§ 1/n then b y else 0)‚Äñ_[‚ä§]) + 2*Œµ := by
    rw [l1Norm_eq_sum, l1Norm_eq_sum]
  _ ‚â§ (Fintype.card Œ±) * Real.sqrt ((‚àë x, a x) * (1/n))
      * Real.sqrt ((‚àë y, b y) * (1 / n)) + 2*Œµ := by
    gcongr
    repeat {
    apply Real.sqrt_le_sqrt
    gcongr
    ¬∑ simp
    ¬∑ split
      simp [abs_of_nonneg]
      simp
    ¬∑ rw [linftyNorm_eq_ciSup]
      apply ciSup_le
      intro
      split
      simp_all only [one_div, Real.norm_eq_abs, ge_iff_le, FinPMF.nonneg, abs_of_nonneg]
      simp [le_of_lt hn]
    }
  _ = (Fintype.card Œ±) * (Real.sqrt (1/n) * Real.sqrt (1 / n)) + 2*Œµ := by simp [mul_assoc]
  _ = (Fintype.card Œ±) * (1 / n) + 2*Œµ := by rw [‚Üê sq]; simp [le_of_lt hn]
  _ = Fintype.card Œ± / n + 2 * Œµ := by ring
